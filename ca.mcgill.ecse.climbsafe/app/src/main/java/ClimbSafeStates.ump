class Member {
  banStatus {
    Unbanned {
      ban() -> Banned;
    }
    Banned {
      unban() -> Unbanned;
    }
  }
}

class Assignment {
  depend ca.mcgill.ecse.climbsafe.model.Member.BanStatus;
  lazy String paymentCode;
  Integer refundPercentage = 0;

  assignmentStatus {
    Unassigned {
      assign(Integer startWeek, Integer endWeek, Guide guide, Hotel hotel) / {
        doAssign(startWeek, endWeek, guide, hotel);
      } -> Assigned;
    }

    Assigned {
      start() / {
        member.ban();
      } -> Assigned;

      pay(String code) [!isBanned()] / {
        doPay(code);
      } -> Paid;
      
      pay(String code) [isBanned()] / {
      	rejectBanAction("pay for");
      } -> Assigned;

      cancel() [!isBanned()] / {
        setRefundPercentage(100);
      } -> Cancelled;
      
      cancel() [isBanned()] / {
      	rejectBanAction("cancel");
      } -> Assigned;

      finish() / {
        rejectTripAction("finish", "not started");
      } -> Assigned;
    }

    Paid {
      pay(String code) / {
        rejectRedundantPayment();
      } -> Paid;

      cancel() [!isBanned()] / {
        setRefundPercentage(50);
      } -> Cancelled;
      
      cancel() [isBanned()] / {
      	rejectBanAction("cancel");
      } -> Paid;

      start() [!isBanned()] -> Started;
      
      start() [isBanned()] / {
      	rejectBanAction("start");
  	  } -> Paid;

      finish() / {
        rejectTripAction("finish", "not started");
      } -> Paid;
    }

    Started {
      cancel() [!isBanned()] / {
        setRefundPercentage(10);
      } -> Cancelled;
      
      cancel() [isBanned()] / {
      	rejectBanAction("cancel");
  	  } -> Started;

      finish() [!isBanned()] / {
        setRefundPercentage(0);
      } -> Finished;
      
      finish() [isBanned()] / {
      	rejectBanAction("finish");
      } -> Started;

      pay(String code) / {
        rejectRedundantPayment();
      } -> Started;
    }

    Finished {
      pay(String code) / {
        rejectTripAction("pay for", "finished");
      } -> Finished;

      start() / {
        rejectTripAction("start", "finished");
      } -> Finished;

      cancel() / {
        rejectTripAction("cancel", "finished");
      } -> Finished;
    }

    Cancelled {
      pay(String code) / {
        rejectTripAction("pay for", "been cancelled");
      } -> Cancelled;

      start() / {
        rejectTripAction("start", "been cancelled");
      } -> Cancelled;

      finish() / {
        rejectTripAction("finish", "been cancelled");
      } -> Cancelled;
    }
  }

  private void doPay(String code) {
    if (code.equals("")) {
      throw new RuntimeException("Invalid authorization code");
    }

    setPaymentCode(code);
  }

  private void doAssign(int startWeek, int endWeek, Guide guide, Hotel hotel) {
    setStartWeek(startWeek);
    setEndWeek(endWeek);
    if (guide != null) {
      setGuide(guide);
    }
    if (hotel != null) {
      setHotel(hotel);
    }
  }

  private boolean isBanned() {
  	return member.getBanStatus().equals(BanStatus.Banned);
  }

  private void rejectTripAction(String verb, String reason) {
    throw new RuntimeException("Cannot " + verb + " a trip which has " + reason);
  }

  private void rejectRedundantPayment() {
    throw new RuntimeException("Trip has already been paid for");
  }
  
  private void rejectBanAction(String verb) {
  	throw new RuntimeException("Cannot " + verb + " the trip due to a ban");
  }
}